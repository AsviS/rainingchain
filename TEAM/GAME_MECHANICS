//More detail during meeting.

//This is a RAW version. 

######
ACTORS
######
4 Main categories of actors. 

   -mortal:
        -player: playable by player. have additional features like passive, permboost, skill, bank, inventory
        -enemy:
            everything that can move or battle is an enemy.
            enemy are loaded via eDb. then use same model than player.
            each enemy has category (troll), variant (ice) and a lvl (10).
            you can also set {extra:something} when adding an enemy for custom feature. (ex: ice troll lvl 10 BUT unlike others, can trigger a specific dialogue)
            
            -non-combat:  do not search for target. move randomly. do not attack    
            -combat:      opposite.
            
                enemy are spawned in groups. enemy are respawned when whole group is dead. 
                once killed, enemy becomes invisble and inactive. counter starts. when counter reaches 100%, they are respawned with init stats.
            
            -boss are like enemy except they run a custom function that is called every frame with targeted players as parameters 
            -enemy mods: list of mods that are applied to enemy when they are spawned (ex: x2 max life, faster atk)
            
    -attack:
        deals damage. they are spawn via an ability. 
        
       -bullet: 1 pixel. moving.
       -strike: rotated square area of effect. not moving. only last for 1 frame.

    -drop: represent an item.
    -anim: animation. anim are not managed by server. server only tells when to start anim and where.
    



################
SERVER BREAKDOWN
################

##START##
connection with db
init server database: use info from db to create internal JSON that acts like database (weaponDb, itemDb etc...)
create an instance of each map
add enemy groups

##PLAYER LOG IN##
client send user and password
server verifies, if ok, send init information about player.
client use info then send clientReady
server add client to list of players

##SERVER LOOP##
client to server:
    client send info as a string, each letters representing an input ex:'00001000010010100'
    for mouse click, theres another system: client send an array when he clicks [mouse_side,x,y]
    server keeps a list of everything the client can click (ex: other actors, interface etc...)
    when client click, server check if the click matches a button 
    
    client can also send command. commands are for non-vital feature (ex: change preference, add friend) 
    check commandShare.js
    
    
server to client
    watchList has the list of variables that are tracked for each actor type.
    every frame, server check if values have changed, if yes, send them to client
    
    watchList only has value that actually change over time.
    
    convertInit has information about what to send when the client needs to draw them for first time and that wont change (ex: name, sprite)
    it is used when sending a new actor to the client

button:
    canvas do not support buttons, so I created custom buttons
    buttons are a area of the canvas. format:[minX,maxX,minY,maxY]
   ----
   ex: 
    addButton({rect:[0,100,0,100],
        left:{func':'addGold','param':[100]}    //if left click in rectangle, call function addGold(100)
    })
    
activeList
    each actor keeps track of other actor surronding him in same map
    when testing collision, it only tests with actors in the activeList (for optimization)

collisions:
    each actor has a bumperbox. bumperbox is 4 pts (right left down up) relative to center of sprite.
    map has a grid represented by 0 = can pass, 1 = cant pass.
    if a bumperbox pt is in a (1 = cant pass) square, player will bounce
    each combat actor also has hitbox. hitbox is for damage and works same way.
    
   
map client side
    map is divide in 2 layer: above player, below player (check drawShare for the full draw list order)
    map is divide in region of about 2000px x 2000px. This is to allow large maps.


instanced world
    create a copy of a map with a model.
    convention: map id = mapmodel + player name (ex: mapId = town2 + sam
    instanced worlds are private.
    
quest
    for each quest, player have a list of variable quest (ex: {bossKilled:0, questRewardReceived:0, openPath:1})
    for every quest function, there will be as parameter, the player id and his quest variable
    check questShare.js for more info

dialogue
    dialogue in db is only used to init dialogue: test variable and startDialogue.
    special functions (ex: add an item) are done inside quest function
    dialogue uses a 3 index system
        npc id:  usually its name
        conversation: usually the name of the question
        node: every dialogue possible 
        ex: (Jenny:KillDragonQuest:congratzPlayer)
        
    dialogue support face. system also allow chained dialogue and custom func to be triggered
    
    I do plan to change the dialogue system for something like morrowind http://puu.sh/5LDFM.jpg

interface
    stage: actors are drawn there. 
        minimap and resources
        tab:inventory, equip, questlist,
    window: bank, trade, quest, passive
    popup: armor info, weapon info.

draw
    the game use canvas and HTML elements
    there are 3 main canvas (stage, window, popup)
    
icon
    there is only 1 iconsheet. each icon has x and y positions
    each icon has a name that can be used with the convert iconIndex
    iconIndex['skill.melee'] return {x:32,y:64}
    iconIndex['skill.range'] return {x:32,y:92}

ability
    everything that a player can cast is ability (attack, buff, curse, summon)
    each ability has a mana cost, speed and function to call when triggered (addSummon, addBoost, performAttack)
    ability is what damage others.
    
bullet
    each bullet have a timer. when 100%, disappear. also disappear if hit map or player
    bullet have moving behaviour (normal, sin, parabole,boomerang etc...)
    bullet can also have special mod: (pierce,ghost)
    bullet are independant. once casted, they no longer need a connection with the shooter
    all damage mods from the player are applied during the creation of the bullet
    
    
strike
    each strike has 9 pts. (top right, top middle, etc...) pts are used for collision
    strike can have a delay between when called, when showing up and when dealing damage.
    (ex: u throw a bomb, bomb waits, bomb explodes)


damage:
    6 elements: melee, range, magic, fire, cold, lightning
    damage is done via ability only. weapons only act as multipliers
    ability have dmgMain (global dmg) and dmgRatio (for each element, sum of ratio = 1)
    ex: fireball: dmgMain = 100, dmgRatio:{fire:0.8,magic:0.2,cold:0,melee:0,range:0,lightning:0}
    
    each armor have defence for each element
    
    the dmg dealt = atkFire/defFire + atkCold/defCold etc... so each element
    
    if attack deals enough damage, it can trigger status effect
    ---
    players can modify their ability with bonus/mastery
    player.bonus.bullet.amount = 2 => player shoots x2 bullets
    check statTo for full list of mods.
    these bonus are received from items, passive grid and quest reward
    

stat: check statTo under statShare.js
    Main Stats:
    element stat: directly impact damage dealt for a certain element
    status effect: each linked with a certain element (ex: fire => burn)
                   each status effect have: chance, magnitude, time (ex: 5% chance to burn for 10 frame for 10% life)
    resist:  decrease magnitude of status effect
    attack mods: bigger Aoe, more bullets, faster bullet etc...
    resource: each resource (hp, mana, fury, dodge) have a current value, a max value, a regen rate.
  
boost:
    two type of boosts:
    regular boost: 
        they are a timer    (ex: curse, buff)
        they are updated every frame. the only thing they can do is increase a stat.
    permBoost: 
        no time     (ex: armor boost, passive)
        they can increase a stat or grant a uniqueBoost (uniqueBoost are a custom function applied to the player)
        
crafting
    when crafting an equip, it requires a seed. 
    seed contains info about what to craft (ex: {'category':'armor',piece:helm,type:bone,lvl:10, quality:1} )
    each weapon/armor have a list of possible boost (check boostDb)
    when creating a weapon, it also creates an item equivalent. both are added to database

passivegrid
    at start server, server loads the passivegrid of every player.
    it calcs the popularity for each bonus and give value for each bonus depending on its popularity


    










